mid隔开的两个区间，总能一个是单调的，一个包含有旋转点

判断单调的方法：
1. a[mid] >= a[0] -> left 单调 -> 将旋转点区间推向右侧
2. a[mid] <= a[n-1] -> right 单调 -> 将旋转点区间推向左侧


固定左端可以采用a[0]，也可以采用a[lo]

---
这是个好问题 👍。我帮你梳理一下什么时候能用固定下标（例如 `nums[0]` 或 `nums[-1]`），什么时候必须用动态下标（例如 `nums[lo]` 或 `nums[hi-1]`）。

------

## 🔹 使用 **固定下标** 的情况

固定下标表示 **整个数组不变的参考点**，常见场景是：

1. **问题本身要求和全局起点/终点比较**
   - 比如经典的「旋转排序数组找最小值」：
      如果 `nums[mid] > nums[-1]`，说明最小值一定在右边。
      因为全局最后一个元素是「旋转点」的基准。
   - 这里逻辑建立在「旋转排序数组只有一个转折点」，所以用 `nums[-1]` 就能作为全局参照。
2. **搜索范围不需要动态缩小**
   - 例如只要找到某个特征（最小值、旋转点），不用二分缩小区间时。
   - 这时 `nums[-1]` 或 `nums[0]` 作为固定锚点是安全的。

------

## 🔹 使用 **动态下标** 的情况

当你做 **二分搜索，且搜索区间不断变化** 时，必须用动态下标：

1. **当前子区间的单调性判断**
   - 例如 `nums[mid] <= nums[hi-1]` 表示 `[mid, hi-1]` 这段是有序的。
   - 但如果用 `nums[-1]`，你就固定死在全局末尾，不能反映收缩后的子区间状态。
2. **排除区间时需要保证不遗漏目标**
   - 当 `hi` 在收缩，只有 `nums[hi-1]` 才是「当前右边界的值」，能保证逻辑正确。
   - 如果你用 `nums[-1]`，可能会「参考错边界」，导致错误跳过目标。

------

## 🔹 总结对比

- **全局参考（旋转点、整体特征）** → 可以用 `nums[0]` 或 `nums[-1]`。
- **局部区间判断（二分搜索缩小范围）** → 必须用 `nums[lo]`、`nums[hi-1]`。

------

要不要我给你画一张「旋转数组二分」的流程图，把 **什么时候用固定下标、什么时候用动态下标** 标出来？这样你在写代码时就能一眼看出来。







对，你说得对——二分时区间确实一直在缩小。关键不在于“是否缩小”，而在于**你用什么不变量（invariant）来做比较**。能不能用固定下标，取决于比较所依赖的是**全局锚点**还是**当前子区间的边界**。

## 什么时候“缩小也能用固定下标”

当你的判断基于**全局不变量**时，哪怕区间在缩小，也可以一直和固定下标比。典型例子：**找旋转点/最小值**。

- 不变量：相对于全局最后一个元素 `nums[-1]`，旋转点左边的元素都 `> nums[-1]`，右边（含最小值）都 `<= nums[-1]`。

- 因此可以写：

  ```python
  # 找最小值下标（可有重复）
  lo, hi = 0, n
  while lo < hi:
      mid = (lo + hi) // 2
      if nums[mid] > nums[-1]:
          lo = mid + 1
      else:
          hi = mid
  # lo 即为最小值位置
  ```

  这里即使区间缩小，比较对象 `nums[-1]` 依然是正确的**全局锚点**，因为我们在找的是“全局阈值在哪儿翻转”，而不是判断当前子区间哪一半有序。

## 什么时候必须用“随区间变化的下标”

当你的判断依赖于**当前子区间的结构**时（例如：要判断“[lo, hi) 内哪一半是有序的”从而决定丢弃哪一半），就必须和**当前边界**比较，而不是全局末尾。

- 典型例子：**在旋转数组中查找目标值（含重复）**。
   判断右半段是否单调要用

  ```python
  nums[mid] <= nums[hi - 1]
  ```

  这里的 `hi - 1` 是**当前窗口的右端点**，不是全局 `-1`。如果改成 `nums[-1]`，你检查的就变成“`[mid, n-1]` 是否像尾部那样有序”，这与“`[mid, hi-1]` 是否有序”不是一回事；当窗口缩到转折点左侧或跨越转折点时，结论可能不同，从而把**错误的一半扔掉**。

## 一句话总结

- **找“全局阈值/旋转点”这类问题**：比较应针对**固定全局锚点**（如 `nums[-1]`），区间缩小也没关系，因为不变量是“相对整个数组尾部”的关系。
- **在当前窗口内做结构判断/决定舍弃哪半**：比较必须用**动态边界**（如 `nums[hi-1]`、`nums[lo]`），否则会用错参照物。

如果你愿意，我可以把这两类写成两段模板代码（含重复元素的细节处理），并配一两个“用全局锚点会误判”的小例子，方便你做单元测试。