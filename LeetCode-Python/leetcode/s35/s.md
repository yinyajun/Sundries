

## 1. 区间的含义

我们维护的区间是 **候选答案的范围**，不是“还没看过的下标”。
不变式是：

* `[0, lo)` 一定 `< target`（左边全不行）
* `[hi, n)` 一定 `>= target`（右边全可行）
* 答案一定在 `[lo, hi)` 里

换句话说，**只要某个位置仍可能是答案，它必须留在 `[lo, hi)` 里**。

---

## 2. 当 `a[mid] >= target`

* `mid` 自己是候选答案（因为它满足 `>= target`）。
* 所以我们必须让它仍然处在 `[lo, hi)` 里。
* 更新 `hi = mid`，新区间是 `[lo, mid)`。

这里有一个关键：**半开区间右端点是不包含的**，所以 `[lo, mid)` 表面上排除了 `mid`，但在逻辑上其实是把 `mid` 放进了“右边的保证区间 `[hi, n)`”里。
而 `[hi, n)` 都保证 `>= target`，所以 `mid` 仍然作为候选被保留下来了。

---

## 3. 为什么不能写 `hi = mid - 1`

如果写成 `hi = mid - 1`，那 `mid` 就既不在 `[lo, hi)`，也不在 `[hi, n)`：

* `[lo, hi)` 缩成 `[lo, mid-1]`，mid 被彻底排除
* `[hi, n)` = `[mid-1, n)`，mid 也不在里面

这样 **mid 完全丢掉**，就有可能错过“第一个符合”的下标。

---

## 4. 一个直观比喻

你可以把 `[lo, hi)` 看成“待定区域”，
`[hi, n)` 看成“保证大于等于 target 的安全区”。

当 `a[mid] >= target` 时，我们把 `hi` 收到 `mid`，
意思是“把 mid 以及右边都放进安全区”。
这就等价于 **保留 mid 作为候选**。

---

## 5. 总结

* 半开区间里 `hi = mid` **不是丢掉 mid**，而是**把 mid 放进右侧保证区**。
* 这样 mid 依然在候选范围中，直到二分结束。
* 最终 `lo == hi`，这个位置就是最左满足条件的下标。


非常好 👍，我们继续用 **“区间视角”** 来看闭区间解法，这样和你之前理解的半开区间逻辑能对应上。

---

## 1. 半开区间回顾

半开 `[lo, hi)` 的思路是：

* `[0, lo)` 全 `< target`
* `[hi, n)` 全 `>= target`
* **未决区间** = `[lo, hi)`
* 最后 `lo==hi` 时，分界点就是答案。

---

## 2. 闭区间维护什么？

闭区间 `[lo, hi]` 的方式不同，它维护的是：

* **未决区间** = `[lo, hi]`（两端都可能包含答案）
* 循环条件是 `lo <= hi`，即“只要未决区间非空”。
* 循环结束时，`lo > hi`，未决区间为空。
* 分界点不在“区间边界”上，而是通过辅助变量 `ans` 来记录。

---

## 3. 两种情况分析

设当前区间是 `[lo, hi]`，取中点 `mid`：

### (1) `a[mid] >= target`

* 说明 `mid` **可能是答案**，但答案也可能更靠左。
* 所以我们：

  * 记录 `ans = mid`（把 `mid` 放入“候选区”）。
  * 把未决区间收缩为 `[lo, mid-1]`。
  * 含义：把右边 `[mid, hi]` 都放进“保证区 ≥ target”，只在左边继续找。

### (2) `a[mid] < target`

* 说明 `mid` 以及它左边都不可能 ≥ target。
* 所以我们：

  * 丢掉 `[lo, mid]`，令 `lo = mid + 1`。
  * 未决区间变为 `[mid+1, hi]`。

---

## 4. 循环结束时

当 `lo > hi`，未决区间为空。
此时答案就在我们之前记录下来的 **最左候选 `ans`** 中。

---

## 5. 举例

数组 `a = [1,2,2,4,7], target = 2`

* 初始：`lo=0, hi=4, ans=5`
* `mid=2 → a[2]=2 >= 2` → `ans=2, hi=1`
  区间缩到 `[0,1]`
* `mid=0 → a[0]=1 < 2` → `lo=1`
  区间缩到 `[1,1]`
* `mid=1 → a[1]=2 >= 2` → `ans=1, hi=0`
  区间缩到 `[1,0]`，空了
* 循环结束，返回 `ans=1` ✅

---

## 6. 和半开区间的对比

* 半开区间：答案体现在“收缩后 lo==hi 的分界点”。
* 闭区间：答案体现在“每次遇到 ≥ target 时记录的 ans”，最后靠 ans 给出。

可以这么理解：

* **半开区间**：分界点在“区间边界”。
* **闭区间**：分界点在“区间内部遇到的候选点”。



---
1. 标准二分查找的目标

目标：找一个等于 target 的下标（任意一个即可）。

关键：一旦找到，就可以立即返回，不需要继续搜索。

所以必须显式判断：

if a[mid] == target:
    return mid


如果省略了这个条件，就没法在发现等于的时候停下来。

2. lower_bound / upper_bound 的目标

lower_bound：找第一个 >= target 的下标。

upper_bound：找第一个 > target 的下标。

这两者的逻辑是偏序搜索，不需要在等于时立刻返回，而是：

a[mid] >= target：缩到左边（因为答案可能更靠左）。

a[mid] < target：缩到右边。

最后停在边界点。
👉 这就是为什么 lower_bound 模板里没有单独的 == 分支。

3. 对比示例

数组 a = [1,2,2,4,7]，target=2

标准二分（等于就返回）

mid=2 → a[2]==2 → 直接返回下标 2

但它不保证返回第一个或最后一个，只保证返回某一个。

lower_bound（第一个 ≥ target）

mid=2 → a[2]==2，缩到左边

mid=0 → a[0]=1<2，缩到右边

mid=1 → a[1]=2>=2，缩到左边

最终停在 1 → 返回第一个满足条件的下标。

4. 总结

标准二分查找：目标是“找到等于 target 的元素”，所以必须写 if a[mid] == target 来立即返回。
边界二分查找（lower_bound / upper_bound）：目标是“找到边界点”，逻辑天然覆盖了 == 的情况，不需要单独判断。