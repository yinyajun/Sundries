## 2. 闭区间更贴合「找极值」

闭区间 `[lo, hi]` 的优势是：

- 区间内所有下标都有效，比较时可以直接用 `nums[hi]` 而不是 `nums[hi-1]`。
- 收缩时，`hi = mid` 或 `lo = mid + 1` 的含义清晰，不会漏掉候选。
- 最后 `lo == hi` 时自然收敛到答案，直接返回即可。

所以闭区间在「找极值 / 边界」类型问题上要直观得多。

------

## 3. 半开区间适用的场景

半开区间在二分里也不是没用武之地，比如：

- 写成「左闭右开」后，可以保证每次收缩区间时，`hi - lo` 严格减小，避免死循环；
- 在实现 `bisect_left` / `bisect_right` 这种函数时，用 `[lo, hi)` 特别自然；
- 在模板化场景（如 STL 的 `lower_bound`）中，半开区间是经典习惯。

# 🔑 二分模板对照表

| 场景         | 半开区间 `[lo, hi)`                                          | 闭区间 `[lo, hi]`                                            |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **区间定义** | `hi` 不包含                                                  | `hi` 包含                                                    |
| **循环条件** | `while lo < hi:`                                             | `while lo < hi:` 或 `while lo <= hi:`（视场景）              |
| **区间长度** | `hi - lo`                                                    | `hi - lo + 1`                                                |
| **取中点**   | `mid = (lo + hi) // 2`                                       | `mid = (lo + hi) // 2`                                       |
| **收缩逻辑** | - `if cond: hi = mid`   - `else: lo = mid + 1`               | - `if cond: hi = mid`   - `else: lo = mid + 1`               |
| **退出条件** | `lo == hi`，区间为空，答案是 `lo`                            | - `lo == hi` 时，区间剩 1 个元素，答案是 `lo`（常见）   - 或 `lo > hi`，答案在循环内 return（查找元素时常见） |
| **典型用途** | `bisect_left` / `bisect_right`、模板化搜索                   | 极值/边界查找（旋转数组最小值、左/右边界）、直接找目标值     |
| **优点**     | - 边界一致：`[lo, hi)` 和 Python/CPP range 一致   - 不容易死循环 | - 更直观，`nums[hi]` 合法，不用写 `hi-1`   - 适合讲解和比赛  |
| **缺点**     | - 要小心处理 `nums[hi-1]`   - 遇到去重逻辑更绕               | - 需要区分 `while lo < hi` vs `while lo <= hi`               |